# Lab Report Processing Flow - Complete Implementation Guide

**Version:** 1.0 Final  
**Date:** November 22, 2025  
**Purpose:** Detailed technical specification for lab report upload and processing

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture Decision](#architecture-decision)
3. [Step-by-Step Flow](#step-by-step-flow)
4. [File Validation](#file-validation)
5. [PDF Text Extraction](#pdf-text-extraction)
6. [Claude Parsing](#claude-parsing)
7. [Data Normalization](#data-normalization)
8. [Storage & Database](#storage--database)
9. [Error Handling](#error-handling)
10. [Testing Requirements](#testing-requirements)

---

## Overview

**Goal:** Process lab reports (PDF/images) and extract biomarker data with 1-3 second response time

**Key Decision:** 
- ❌ NOT using AI vision (slow, 30-60s, expensive, unreliable)
- ✅ Using PDF text extraction → Claude Haiku 4.5 text parsing

**Performance:**
- Clean PDF: 1-2 seconds
- Scanned PDF: 3-4 seconds (includes OCR)
- Batch of 30 files: 3-5 minutes

---

## Architecture Decision

### Why Not AI Vision?

**Problems with Claude Vision API:**
- Takes 30-60+ seconds per file
- Frequent timeouts (especially in edge functions)
- Expensive ($3-7 per 1000 images)
- Struggles with non-English text
- Poor unit conversion handling
- Edge function memory limits exceeded

### New Approach: Text Extraction + Text Parsing

**Step 1: Extract Text**
- Most lab PDFs are digital (have selectable text)
- Use `pdfjs-dist` to extract text directly (instant, free)
- For scanned PDFs: Use AWS Textract OCR (2 seconds, 95% accurate)

**Step 2: Parse Text**
- Send extracted text to Claude Haiku 4.5 (fast, cheap)
- Get structured JSON back
- 1-2 second response time

**Benefits:**
- 10-20x faster (2-3s vs 30-60s)
- 50x cheaper ($0.001 vs $0.05+ per report)
- No timeouts
- Better with multiple languages
- Scales to parallel processing

---

## Step-by-Step Flow

### High-Level Pipeline

```
User uploads file
    ↓
Client-side validation (type, size)
    ↓
Upload to Supabase Storage
    ↓
Extract text (pdfjs or Textract)
    ↓
Parse with Claude Haiku 4.5
    ↓
Normalize & validate data
    ↓
Match/create client
    ↓
Store results in database
    ↓
Display to user
```

### Detailed Steps

**1. File Selection (Client-side)**
- User drags files or clicks to browse
- Multiple file selection supported
- Real-time preview with file list

**2. Client Validation (Client-side)**
- Check file type: PDF, JPG, PNG only
- Check size: Max 10 MB per file
- Check count: Max 20 files per batch
- Show errors immediately

**3. Upload to Storage (Client-side → Supabase)**
- Path: `{practitioner_id}/{client_id}/{analysis_id}/filename.pdf`
- Stream upload (no buffering entire file)
- Progress tracking per file

**4. Server-side Validation (Edge Function)**
- Re-validate type and size (don't trust client)
- Magic number check (verify file isn't spoofed)
- Password-protected PDF detection

**5. Text Extraction (Serverless Function - Node.js)**
- Try pdfjs first (instant, free)
- If no text found → Use AWS Textract (2s, $0.0015/page)
- Handle errors (corrupt files, etc.)

**6. Claude Parsing (Serverless Function - Node.js)**
- Send text to Claude Haiku 4.5
- Structured prompt for JSON output
- 1-2 second response time
- Retry logic (3 attempts with backoff)

**7. Data Validation & Normalization (Server-side)**
- Validate JSON structure
- Fuzzy match biomarker names to database
- Convert units if needed
- Determine status (normal/high/low)

**8. Client Matching (Server-side)**
- Extract patient info (name, DOB, gender)
- Search for existing client
- Calculate match confidence
- Show confirmation modal to user

**9. Database Storage (Server-side)**
- Create/link client
- Create analysis record
- Insert biomarker results
- Move files to proper storage location

**10. Display Results (Client-side)**
- Show summary (counts by status)
- Show detailed table with all biomarkers
- Enable export/download options

---

## File Validation

### Client-Side Validation

**Purpose:** Fast feedback, prevent unnecessary uploads

```typescript
// lib/file-validation.ts
export function validateFile(file: File): { valid: boolean; error?: string } {
  // 1. Type check
  const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png'];
  if (!allowedTypes.includes(file.type)) {
    return { valid: false, error: 'Only PDF and image files are supported' };
  }
  
  // 2. Size check (10 MB)
  const maxSize = 10 * 1024 * 1024;
  if (file.size > maxSize) {
    return { valid: false, error: `File exceeds 10MB limit (${(file.size / 1024 / 1024).toFixed(1)}MB)` };
  }
  
  // 3. Name check
  if (file.name.length > 255) {
    return { valid: false, error: 'Filename too long' };
  }
  
  return { valid: true };
}

export function validateBatch(files: File[]): { validFiles: File[]; errors: string[] } {
  const validFiles: File[] = [];
  const errors: string[] = [];
  
  // Check count
  if (files.length > 20) {
    errors.push('Maximum 20 files per upload');
    return { validFiles: [], errors };
  }
  
  // Check duplicates
  const names = new Set();
  
  files.forEach(file => {
    if (names.has(file.name)) {
      errors.push(`Duplicate file: ${file.name}`);
      return;
    }
    
    const result = validateFile(file);
    if (result.valid) {
      validFiles.push(file);
      names.add(file.name);
    } else {
      errors.push(`${file.name}: ${result.error}`);
    }
  });
  
  return { validFiles, errors };
}
```

### Server-Side Validation

**Purpose:** Security, can't trust client

```typescript
// api/upload/validate.ts
export const config = { runtime: 'edge' };

export async function POST(req: Request) {
  // Stream-based size check (don't buffer entire file)
  const contentLength = req.headers.get('content-length');
  if (contentLength && parseInt(contentLength) > 10 * 1024 * 1024) {
    return Response.json({ 
      error: 'File exceeds 10MB limit' 
    }, { status: 400 });
  }
  
  const formData = await req.formData();
  const file = formData.get('file') as Blob;
  
  if (!file) {
    return Response.json({ error: 'No file provided' }, { status: 400 });
  }
  
  // Type check
  const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png'];
  if (!allowedTypes.includes(file.type)) {
    return Response.json({ error: 'Invalid file type' }, { status: 400 });
  }
  
  // Magic number validation (read first 4 bytes only)
  const buffer = await file.slice(0, 4).arrayBuffer();
  const bytes = new Uint8Array(buffer);
  
  const isPDF = bytes[0] === 0x25 && bytes[1] === 0x50 && bytes[2] === 0x44 && bytes[3] === 0x46;
  const isJPEG = bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[2] === 0xFF;
  const isPNG = bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47;
  
  if (!isPDF && !isJPEG && !isPNG) {
    return Response.json({ 
      error: 'File content does not match extension' 
    }, { status: 400 });
  }
  
  return Response.json({ valid: true });
}
```

---

## PDF Text Extraction

### Primary Method: pdfjs-dist

**When:** PDF has selectable text (90% of lab reports)  
**Speed:** Instant  
**Cost:** Free

```typescript
// lib/pdf-processor.ts
import { getDocument, GlobalWorkerOptions } from 'pdfjs-dist';

// Set worker path
GlobalWorkerOptions.workerSrc = new URL(
  'pdfjs-dist/build/pdf.worker.min.mjs',
  import.meta.url
).toString();

export async function extractTextFromPDF(file: File): Promise<string> {
  try {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await getDocument({ data: arrayBuffer }).promise;
    
    let fullText = '';
    
    // Extract text from each page
    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const textContent = await page.getTextContent();
      
      const pageText = textContent.items
        .map((item: any) => item.str)
        .join(' ');
      
      fullText += pageText + '\n\n';
    }
    
    return fullText;
    
  } catch (error) {
    if (error.name === 'PasswordException') {
      throw new Error('PASSWORD_PROTECTED');
    }
    if (error.name === 'InvalidPDFException') {
      throw new Error('CORRUPT_FILE');
    }
    throw error;
  }
}
```

### Fallback Method: AWS Textract

**When:** No text found in PDF (scanned/image-only)  
**Speed:** 2 seconds  
**Cost:** $0.0015 per page

```typescript
// lib/ocr-processor.ts
import { TextractClient, AnalyzeDocumentCommand } from '@aws-sdk/client-textract';

const textract = new TextractClient({
  region: 'us-east-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!
  },
  maxAttempts: 3,
  requestHandler: {
    requestTimeout: 30000
  }
});

export async function extractTextWithOCR(imageBuffer: Buffer, practitionerId: string): Promise<string> {
  // Check monthly budget
  const withinBudget = await checkTextractBudget(practitionerId);
  if (!withinBudget) {
    throw new Error('TEXTRACT_BUDGET_EXCEEDED');
  }
  
  const command = new AnalyzeDocumentCommand({
    Document: { Bytes: imageBuffer },
    FeatureTypes: ['TABLES', 'FORMS'] // Extract tables and form data
  });
  
  const response = await textract.send(command);
  
  // Log usage
  await logTextractUsage(practitionerId, 1, 0.0015);
  
  // Extract text from blocks
  const text = response.Blocks
    ?.filter(block => block.BlockType === 'LINE')
    .map(block => block.Text)
    .join('\n') || '';
  
  return text;
}

async function checkTextractBudget(practitionerId: string): Promise<boolean> {
  const { data } = await supabase
    .from('textract_usage')
    .select('page_count')
    .eq('practitioner_id', practitionerId)
    .gte('created_at', startOfMonth())
    .single();
  
  const monthlyPages = data?.page_count || 0;
  const LIMIT = 1000; // $1.50 per practitioner per month
  
  return monthlyPages < LIMIT;
}
```

### Decision Logic

```typescript
// api/analyze.ts
export async function processLabReport(file: File, practitionerId: string) {
  let extractedText = '';
  
  // Step 1: Try text extraction
  if (file.type === 'application/pdf') {
    try {
      extractedText = await extractTextFromPDF(file);
      
      // Check if meaningful text was extracted
      if (extractedText.trim().length < 100) {
        console.log('No text found, falling back to OCR');
        extractedText = '';
      }
    } catch (error) {
      if (error.message === 'PASSWORD_PROTECTED') {
        return {
          status: 'failed',
          error: 'PASSWORD_PROTECTED',
          userMessage: 'This PDF is password protected. Please remove the password and try again.'
        };
      }
      if (error.message === 'CORRUPT_FILE') {
        return {
          status: 'failed',
          error: 'CORRUPT_FILE',
          userMessage: 'This file appears to be corrupted. Please re-export from the original source.'
        };
      }
      throw error;
    }
  }
  
  // Step 2: If no text, use OCR
  if (!extractedText || extractedText.length < 100) {
    const buffer = await file.arrayBuffer();
    try {
      extractedText = await extractTextWithOCR(Buffer.from(buffer), practitionerId);
    } catch (error) {
      if (error.message === 'TEXTRACT_BUDGET_EXCEEDED') {
        return {
          status: 'failed',
          error: 'BUDGET_EXCEEDED',
          userMessage: 'Monthly OCR limit reached. Limit resets on the 1st of each month. Contact support for a higher limit.'
        };
      }
      throw error;
    }
  }
  
  // Step 3: Parse with Claude
  return await parseWithClaude(extractedText, practitionerId);
}
```

---

## Claude Parsing

### Prompt Engineering

**Goal:** Get structured JSON with patient info and biomarkers

```typescript
// lib/claude-parser.ts
const EXTRACTION_PROMPT = `You are analyzing a clinical lab report. Extract ALL biomarkers and patient information.

CRITICAL RULES:
1. Return ONLY valid JSON (no markdown, no explanations)
2. Extract EVERY biomarker found (do not skip any)
3. Use exact biomarker names as they appear
4. Convert all values to numbers (remove commas, units)
5. Preserve units separately
6. Use null for missing data

Output format:
{
  "patient": {
    "name": "string or null",
    "dob": "YYYY-MM-DD or null",
    "gender": "Male/Female/Other or null",
    "test_date": "YYYY-MM-DD or null"
  },
  "biomarkers": [
    {
      "name": "Glucose (Fasting)",
      "value": 95,
      "unit": "mg/dL",
      "reference_range": "70-100",
      "status": "Normal" 
    }
  ]
}`;

export async function parseWithClaude(
  text: string, 
  practitionerId: string,
  attempt: number = 1
): Promise<any> {
  // Check budget
  const withinBudget = await checkClaudeBudget(practitionerId);
  if (!withinBudget) {
    throw new Error('CLAUDE_BUDGET_EXCEEDED');
  }
  
  // Truncate if too long (preserve structure)
  const truncatedText = truncateText(text, 100_000);
  
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000);
    
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': process.env.ANTHROPIC_API_KEY!,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-haiku-4-5-20251001',
        max_tokens: 4000,
        messages: [{
          role: 'user',
          content: `${EXTRACTION_PROMPT}\n\nLab Report Text:\n${truncatedText}`
        }]
      }),
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      throw new Error(`Claude API error: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Log usage (NEVER log the actual text/response)
    await logClaudeUsage(practitionerId, data.usage.total_tokens);
    
    // Parse response (strip markdown if present)
    let responseText = data.content[0].text;
    responseText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    const parsed = JSON.parse(responseText);
    
    // Validate structure
    validateClaudeResponse(parsed);
    
    return parsed;
    
  } catch (error) {
    if (attempt >= 3) throw error;
    
    // Exponential backoff: 1s, 2s, 4s
    await sleep(1000 * Math.pow(2, attempt - 1));
    return parseWithClaude(text, practitionerId, attempt + 1);
  }
}

function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  
  // Keep 60% from start, 40% from end (preserves context)
  const keepStart = Math.floor(maxLength * 0.6);
  const keepEnd = Math.floor(maxLength * 0.4);
  
  const start = text.substring(0, keepStart);
  const end = text.substring(text.length - keepEnd);
  
  return start + '\n\n[... content truncated ...]\n\n' + end;
}

function validateClaudeResponse(data: any): void {
  if (!data.patient) {
    throw new Error('Missing patient info');
  }
  
  if (!Array.isArray(data.biomarkers) || data.biomarkers.length === 0) {
    throw new Error('No biomarkers found');
  }
  
  // Validate each biomarker
  data.biomarkers.forEach((marker: any, index: number) => {
    if (!marker.name || marker.value === null || marker.value === undefined) {
      throw new Error(`Invalid biomarker at index ${index}`);
    }
    
    // Ensure value is numeric
    if (typeof marker.value !== 'number') {
      const parsed = parseFloat(marker.value);
      if (isNaN(parsed)) {
        throw new Error(`Non-numeric value for ${marker.name}: ${marker.value}`);
      }
      marker.value = parsed;
    }
  });
}

async function checkClaudeBudget(practitionerId: string): Promise<boolean> {
  const { data } = await supabase
    .from('claude_usage')
    .select('token_count')
    .eq('practitioner_id', practitionerId)
    .gte('created_at', startOfMonth())
    .single();
  
  const monthlyTokens = data?.token_count || 0;
  const LIMIT = 1_000_000; // ~$3 per practitioner
  
  return monthlyTokens < LIMIT;
}

async function logClaudeUsage(practitionerId: string, tokens: number): Promise<void> {
  await supabase.from('claude_usage').insert({
    practitioner_id: practitionerId,
    token_count: tokens,
    cost: tokens * 0.000003, // $3 per 1M tokens
    created_at: new Date().toISOString()
  });
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

---

## Data Normalization

### Biomarker Name Matching

**Problem:** Claude extracts "Glucose, Fasting" but database has "Glucose (Fasting)"

```typescript
// lib/biomarker-matcher.ts
export async function matchBiomarkerName(extractedName: string): Promise<{
  matched: boolean;
  standardName: string;
  confidence: 'high' | 'medium' | 'low';
}> {
  // Get all benchmarks
  const { data: benchmarks } = await supabase
    .from('benchmarks')
    .select('name, aliases');
  
  // Try exact match first
  const exactMatch = benchmarks.find(b => 
    b.name.toLowerCase() === extractedName.toLowerCase()
  );
  
  if (exactMatch) {
    return {
      matched: true,
      standardName: exactMatch.name,
      confidence: 'high'
    };
  }
  
  // Try alias match
  for (const benchmark of benchmarks) {
    if (benchmark.aliases?.some((alias: string) => 
      alias.toLowerCase() === extractedName.toLowerCase()
    )) {
      return {
        matched: true,
        standardName: benchmark.name,
        confidence: 'high'
      };
    }
  }
  
  // Try fuzzy match
  const normalized = normalizeString(extractedName);
  
  for (const benchmark of benchmarks) {
    const benchmarkNorm = normalizeString(benchmark.name);
    const similarity = calculateSimilarity(normalized, benchmarkNorm);
    
    if (similarity > 0.85) {
      return {
        matched: true,
        standardName: benchmark.name,
        confidence: 'medium'
      };
    }
  }
  
  // No match found - use original name
  return {
    matched: false,
    standardName: extractedName,
    confidence: 'low'
  };
}

function normalizeString(str: string): string {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '') // Remove punctuation
    .trim();
}

function calculateSimilarity(str1: string, str2: string): number {
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;
  
  if (longer.length === 0) return 1.0;
  
  const editDistance = levenshteinDistance(longer, shorter);
  return (longer.length - editDistance) / longer.length;
}

function levenshteinDistance(str1: string, str2: string): number {
  const matrix: number[][] = [];
  
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1, // substitution
          matrix[i][j - 1] + 1,     // insertion
          matrix[i - 1][j] + 1      // deletion
        );
      }
    }
  }
  
  return matrix[str2.length][str1.length];
}
```

### Unit Conversion

**Problem:** Lab uses mmol/L but database expects mg/dL

```typescript
// lib/unit-converter.ts
const CONVERSION_FACTORS: Record<string, Record<string, number>> = {
  'glucose': {
    'mmol/L->mg/dL': 18,
    'mg/dL->mmol/L': 1/18
  },
  'cholesterol': {
    'mmol/L->mg/dL': 38.67,
    'mg/dL->mmol/L': 1/38.67
  },
  'triglycerides': {
    'mmol/L->mg/dL': 88.57,
    'mg/dL->mmol/L': 1/88.57
  }
};

export function convertUnit(
  biomarkerName: string,
  value: number,
  fromUnit: string,
  toUnit: string
): number | null {
  // No conversion needed
  if (fromUnit === toUnit) return value;
  
  // Find conversion factor
  const biomarkerKey = biomarkerName.toLowerCase().split(' ')[0];
  const conversions = CONVERSION_FACTORS[biomarkerKey];
  
  if (!conversions) return null; // Unknown biomarker
  
  const conversionKey = `${fromUnit}->${toUnit}`;
  const factor = conversions[conversionKey];
  
  if (!factor) return null; // Unknown conversion
  
  return value * factor;
}
```

### Status Determination

**Problem:** Determine if value is normal, high, or low

```typescript
// lib/status-calculator.ts
export async function determineStatus(
  biomarkerName: string,
  value: number,
  unit: string,
  gender: string
): Promise<'normal' | 'high' | 'low' | 'unknown'> {
  // Get benchmark
  const { data: benchmark } = await supabase
    .from('benchmarks')
    .select('*')
    .eq('name', biomarkerName)
    .single();
  
  if (!benchmark) return 'unknown';
  
  // Convert units if needed
  let comparableValue = value;
  if (unit !== benchmark.unit) {
    const converted = convertUnit(biomarkerName, value, unit, benchmark.unit);
    if (converted === null) return 'unknown';
    comparableValue = converted;
  }
  
  // Get appropriate range based on gender
  const min = gender === 'Female' ? benchmark.female_min : benchmark.male_min;
  const max = gender === 'Female' ? benchmark.female_max : benchmark.male_max;
  
  if (min === null || max === null) return 'unknown';
  
  // Determine status
  if (comparableValue < min) return 'low';
  if (comparableValue > max) return 'high';
  return 'normal';
}
```

---

## Storage & Database

### File Storage

**Path structure:** `{practitioner_id}/{client_id}/{analysis_id}/filename.pdf`

```typescript
// lib/storage-manager.ts
export async function uploadLabFile(
  file: File,
  practitionerId: string,
  clientId: string,
  analysisId: string
): Promise<string> {
  // CRITICAL: Always use this path structure
  const filePath = `${practitionerId}/${clientId}/${analysisId}/${file.name}`;
  
  const { data, error } = await supabase.storage
    .from('lab-reports')
    .upload(filePath, file, {
      cacheControl: '3600',
      upsert: false
    });
  
  if (error) throw error;
  
  return filePath;
}
```

### Database Schema

```sql
-- Store analysis record
CREATE TABLE analyses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  practitioner_id UUID NOT NULL REFERENCES practitioners(id),
  client_id UUID NOT NULL REFERENCES clients(id),
  analyzed_at TIMESTAMP DEFAULT NOW(),
  file_count INT NOT NULL,
  file_paths TEXT[] NOT NULL,
  biomarker_count INT NOT NULL,
  status TEXT NOT NULL DEFAULT 'completed'
);

-- Store individual biomarker results
CREATE TABLE analysis_results (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  analysis_id UUID NOT NULL REFERENCES analyses(id),
  practitioner_id UUID NOT NULL REFERENCES practitioners(id),
  client_id UUID NOT NULL REFERENCES clients(id),
  biomarker_name TEXT NOT NULL,
  value NUMERIC NOT NULL,
  unit TEXT NOT NULL,
  reference_range TEXT,
  status TEXT NOT NULL, -- 'normal', 'high', 'low', 'unknown'
  measured_at TIMESTAMP DEFAULT NOW()
);
```

### Save Results

```typescript
// lib/results-saver.ts
export async function saveAnalysisResults(
  practitionerId: string,
  clientId: string,
  biomarkers: Array<any>,
  filePaths: string[]
): Promise<string> {
  // Create analysis record
  const { data: analysis, error: analysisError } = await supabase
    .from('analyses')
    .insert({
      practitioner_id: practitionerId,
      client_id: clientId,
      analyzed_at: new Date().toISOString(),
      file_count: filePaths.length,
      file_paths: filePaths,
      biomarker_count: biomarkers.length,
      status: 'completed'
    })
    .select()
    .single();
  
  if (analysisError) throw analysisError;
  
  // Prepare biomarker records
  const biomarkerRecords = biomarkers.map(marker => ({
    analysis_id: analysis.id,
    practitioner_id: practitionerId,
    client_id: clientId,
    biomarker_name: marker.standardName,
    value: marker.value,
    unit: marker.unit,
    reference_range: marker.reference_range,
    status: marker.status,
    measured_at: new Date().toISOString()
  }));
  
  // Batch insert
  const { error: markersError } = await supabase
    .from('analysis_results')
    .insert(biomarkerRecords);
  
  if (markersError) throw markersError;
  
  return analysis.id;
}
```

---

## Error Handling

### Error Types

```typescript
// lib/processing-errors.ts
export class ProcessingError extends Error {
  constructor(
    public code: string,
    public userMessage: string,
    public details?: any
  ) {
    super(userMessage);
    this.name = 'ProcessingError';
  }
}

// Error codes
export const ErrorCodes = {
  PASSWORD_PROTECTED: 'PASSWORD_PROTECTED',
  CORRUPT_FILE: 'CORRUPT_FILE',
  NO_TEXT_FOUND: 'NO_TEXT_FOUND',
  TEXTRACT_BUDGET_EXCEEDED: 'TEXTRACT_BUDGET_EXCEEDED',
  CLAUDE_BUDGET_EXCEEDED: 'CLAUDE_BUDGET_EXCEEDED',
  INVALID_DATA: 'INVALID_DATA',
  NO_BIOMARKERS: 'NO_BIOMARKERS'
};

// User-friendly messages
export const ErrorMessages = {
  [ErrorCodes.PASSWORD_PROTECTED]: 'This PDF is password protected. Please remove the password and try again.',
  [ErrorCodes.CORRUPT_FILE]: 'This file appears to be corrupted. Please re-export from the original source.',
  [ErrorCodes.NO_TEXT_FOUND]: 'No readable text found in this file. Please ensure it\'s a valid lab report.',
  [ErrorCodes.TEXTRACT_BUDGET_EXCEEDED]: 'Monthly OCR limit reached. Limit resets on the 1st of each month. Contact support for assistance.',
  [ErrorCodes.CLAUDE_BUDGET_EXCEEDED]: 'Monthly processing limit reached. Limit resets on the 1st of each month. Contact support if you need a higher limit.',
  [ErrorCodes.INVALID_DATA]: 'Unable to parse this lab report. Please ensure it\'s in a standard format.',
  [ErrorCodes.NO_BIOMARKERS]: 'No biomarkers found in this report. Please verify it\'s a lab test result.'
};
```

### Error Handler

```typescript
// api/analyze.ts
export async function handleProcessingError(error: any) {
  // Log error (without PII)
  logger.error('Processing failed', {
    error_code: error.code,
    error_name: error.name,
    // NO: error.message, error.stack (might contain PII)
  });
  
  // Map to user-friendly response
  if (error instanceof ProcessingError) {
    return {
      status: 'failed',
      error: error.code,
      userMessage: error.userMessage
    };
  }
  
  // Unknown error
  return {
    status: 'failed',
    error: 'UNKNOWN_ERROR',
    userMessage: 'An unexpected error occurred. Please try again or contact support.'
  };
}
```

### Partial Success Handling

**Scenario:** User uploads 10 files, 7 succeed, 3 fail

```typescript
// api/batch-process.ts
export async function processBatch(files: File[], practitionerId: string) {
  const results = [];
  
  for (const file of files) {
    try {
      const result = await processLabReport(file, practitionerId);
      results.push({
        fileName: file.name,
        status: 'success',
        data: result
      });
    } catch (error) {
      results.push({
        fileName: file.name,
        status: 'failed',
        error: handleProcessingError(error)
      });
    }
  }
  
  const successCount = results.filter(r => r.status === 'success').length;
  const failureCount = results.filter(r => r.status === 'failed').length;
  
  return {
    summary: {
      total: files.length,
      successful: successCount,
      failed: failureCount
    },
    results
  };
}
```

---

## Testing Requirements

### Unit Tests

```typescript
// test/pdf-processor.test.ts
describe('PDF Text Extraction', () => {
  test('extracts text from digital PDF', async () => {
    const pdf = await loadTestFile('digital-lab.pdf');
    const text = await extractTextFromPDF(pdf);
    expect(text).toContain('Glucose');
    expect(text.length).toBeGreaterThan(100);
  });
  
  test('handles password-protected PDF', async () => {
    const pdf = await loadTestFile('password-protected.pdf');
    await expect(extractTextFromPDF(pdf)).rejects.toThrow('PASSWORD_PROTECTED');
  });
  
  test('handles corrupt PDF', async () => {
    const pdf = await loadTestFile('corrupt.pdf');
    await expect(extractTextFromPDF(pdf)).rejects.toThrow('CORRUPT_FILE');
  });
});

describe('Claude Parsing', () => {
  test('parses valid lab report text', async () => {
    const text = `Patient: John Doe
    DOB: 1985-06-15
    Glucose: 95 mg/dL (70-100)`;
    
    const result = await parseWithClaude(text, 'test-practitioner');
    expect(result.patient.name).toBe('John Doe');
    expect(result.biomarkers).toHaveLength(1);
    expect(result.biomarkers[0].name).toContain('Glucose');
  });
  
  test('handles empty text', async () => {
    await expect(parseWithClaude('', 'test-practitioner')).rejects.toThrow();
  });
});

describe('Biomarker Matching', () => {
  test('matches exact name', async () => {
    const result = await matchBiomarkerName('Glucose (Fasting)');
    expect(result.matched).toBe(true);
    expect(result.confidence).toBe('high');
  });
  
  test('matches alias', async () => {
    const result = await matchBiomarkerName('HbA1c');
    expect(result.matched).toBe(true);
    expect(result.standardName).toBe('Hemoglobin A1C');
  });
  
  test('fuzzy matches similar name', async () => {
    const result = await matchBiomarkerName('Glucose, Fasting');
    expect(result.matched).toBe(true);
    expect(result.confidence).toBe('medium');
  });
});
```

### Integration Tests

```typescript
// test/processing-flow.test.ts
describe('Complete Processing Flow', () => {
  test('processes digital PDF successfully', async () => {
    const file = await loadTestFile('sample-lab.pdf');
    const result = await processLabReport(file, 'test-practitioner');
    
    expect(result.patient).toBeDefined();
    expect(result.biomarkers.length).toBeGreaterThan(0);
    expect(result.biomarkers[0]).toHaveProperty('status');
  });
  
  test('handles scanned PDF with OCR', async () => {
    const file = await loadTestFile('scanned-lab.pdf');
    const result = await processLabReport(file, 'test-practitioner');
    
    expect(result.patient).toBeDefined();
    expect(result.biomarkers.length).toBeGreaterThan(0);
  });
  
  test('processes batch with partial failures', async () => {
    const files = [
      await loadTestFile('good-lab.pdf'),
      await loadTestFile('corrupt.pdf'),
      await loadTestFile('good-lab-2.pdf')
    ];
    
    const result = await processBatch(files, 'test-practitioner');
    
    expect(result.summary.successful).toBe(2);
    expect(result.summary.failed).toBe(1);
  });
});
```

### Performance Tests

```typescript
// test/performance.test.ts
describe('Performance Requirements', () => {
  test('processes digital PDF under 3 seconds', async () => {
    const file = await loadTestFile('sample-lab.pdf');
    const start = Date.now();
    
    await processLabReport(file, 'test-practitioner');
    
    const duration = Date.now() - start;
    expect(duration).toBeLessThan(3000);
  });
  
  test('processes 30 files under 5 minutes', async () => {
    const files = Array(30).fill(null).map(() => loadTestFile('sample-lab.pdf'));
    const start = Date.now();
    
    await processBatch(await Promise.all(files), 'test-practitioner');
    
    const duration = Date.now() - start;
    expect(duration).toBeLessThan(5 * 60 * 1000);
  });
});
```

---

## Implementation Checklist

- [ ] Set up pdfjs-dist in Node.js serverless function
- [ ] Configure AWS Textract credentials
- [ ] Create Claude API integration with Haiku 4.5
- [ ] Implement budget tracking tables (claude_usage, textract_usage)
- [ ] Build biomarker matching logic
- [ ] Implement unit conversion
- [ ] Create status determination logic
- [ ] Set up proper error handling
- [ ] Add logging (without PII)
- [ ] Write unit tests
- [ ] Write integration tests
- [ ] Test with real lab reports (digital + scanned)
- [ ] Load test with 30+ files
- [ ] Deploy to staging
- [ ] Monitor performance metrics
- [ ] Deploy to production

---

**End of Processing Flow Documentation**